import re, os
import sys
from config import *

# super(self).init__() ?

top_class_body = """
class %s(VM_Inst_With_Suff):
    def __init__(self):
        self.mnem = "%s"
        VM_Inst_With_Suff.__init__(self)
"""

small_class_body = """
class VM_%s(%s):
    def __init__(self):
        self.fn = "%s.txt"
        self.size = %d
        %s.__init__(self)
"""

disasm = """
    def disasm(self, param):
        d = VM_Inst_With_Suff.disasm(self, param)
        %s
        return d
"""

def gen_bwd(mnem, top_class_name, fn_list, custom_disasm):
    top_class = top_class_body%(top_class_name, mnem)
    if custom_disasm:
        dis_proc = disasm%custom_disasm
        top_class += "\n" + dis_proc
    
    if len(fn_list)==3:
        sizes = [8,16,32]
    elif len(fn_list)==2:
        sizes = [16,32]
    else:
        assert(False)
    
    fn_list = zip(fn_list, sizes)
    out = top_class  
    for fn,size in fn_list:
        small_class = small_class_body%(fn, top_class_name, fn, size, top_class_name)
        out += small_class
    
    return out

def add_generated(new, d):
    for h in new:
        d[h] = 1
    return d

def extract_small_names(s):
    l = re.findall(r"class (VM_.*?)\(", s)
    return l

if __name__=="__main__":

# not;VM_Not;001,002,003;d+=foo;
    
    if len(sys.argv)<2:
        print sys.argv[0], "<info file> [vm_instructions.py]"
        sys.exit(1)
    
    src_fn = None
    if len(sys.argv)==3:
        src_fn = sys.argv[2]

    f = open(sys.argv[1])
    l = f.readlines()
    f.close()

    l = map(lambda x: x.strip(), l)

    all_handlers = os.listdir("clean_handlers")
    generated_handlers = dict()

    pre = "# AUTOGENERATED BY gen_vmi.py\n# DO NOT EDIT!\n"
    pre += "from vmi_top_common import *"

    print pre

    prefix = "VM_"
    
    classes = []
    for line in l:
        line = re.sub(r"#.*", "", line)
        if not line:
            continue
        mnem, class_name, fn_list, custom_disasm = line.split(";")
        clean = re.sub(r"\s+", "", custom_disasm)
        if clean == "":
            custom_disasm = None

        fn_list = fn_list.split(",")
        fn_count = len(fn_list) 

        if fn_count==1:
            n = int(fn_list[0], 16)
            fn_list = [n, n+1, n+2]
            fn_list = map(lambda n: hex(n).replace("0x",""), fn_list)
            fn_list = map(lambda s: "0"*(3-len(s))+s, fn_list)

        generated_handlers = add_generated(fn_list, generated_handlers)

        if not class_name:
            class_name = prefix + mnem.title()
        else:
            class_name = prefix + class_name.title().replace(" ", "_")

        o = gen_bwd(mnem, class_name, fn_list, custom_disasm)

        print o

        small = extract_small_names(o)
        classes += small
   
    #print "# not handled:"

    not_handled = []
    for h_fn in all_handlers:
        h_id = h_fn.replace(".txt", "")
        try:
            generated_handlers[h_id]
            continue
        except:
            pass

        #print "# ", h_fn
        not_handled.append(h_id)
    
    if src_fn != None:
        classes.sort()
        f = open(src_fn, "r")
        src = f.read()
        f.close()

        #ocaml..
        def seek(cn, callback):
            cn = "class "+cn
            res = src.find(cn)>=0
            callback(res, cn, src_fn)

        def remove_f(found, cn, src_fn):
            if found:
                print "# remove %s from %s!"%(cn, src_fn)

        def add_f(found, cn, src_fn):
            if not found:
                print "# add %s to %s!"%(cn, src_fn)

        for cn in classes:
            seek(cn, remove_f)
        
        not_handled = map(lambda x: prefix+x, not_handled) 

        for cn in not_handled:
            seek(cn, add_f)

